package cmd

import (
	"encoding/json"
	"fmt"
	"github.com/IBAX-io/go-ibax-sdk/packages/request"
	"github.com/IBAX-io/ibax-cli/models"
	"github.com/IBAX-io/ibax-cli/packages/parameter"
	log "github.com/sirupsen/logrus"
	"github.com/spf13/cobra"
	"os"
	"strings"
)

// contract
var (
	getContracts = &cobra.Command{
		Use:   "getContracts [Limit] [Offset]",
		Short: "Get contracts list",
		Long: `
Get the list of contracts in the current ecosystem, and you can set the offset and number of entries.
Request:
	Limit			(number,optional) limit, the default is 10, and the maximum is 100
	Offset			(number,optional) offset, default is 0

Returns a json object for Contracts list
Result:
	{
		"count": n,							(number) total
		"list": [							(array) Each element in the array contains the following parameters:
			{
				"address": "str",			(string) The wallet address XXXX-...-XXXX bound to the contract.
				"app_id": "str",			(string) The application ID to which the contract belongs.
				"conditions": "str",		(string) Conditions to change the contract.
				"ecosystem_id": "str",		(string) The ecosystem id to which the contract belongs.
				"id": "str",				(string) Contract ID.
				"name": "str",				(string) Contract name.
				"token_id": "str",			(string) The ecosystem ID of the token used to pay contract fees.
				"value": "str",				(string) Contract content.
				"wallet_id": "str"			(string) The account address bound to the contract.
			}
		]
	}
`,
		SuggestFor: []string{"getContracts"},
		Example:    "./ibax-cli getContracts [Limit] [Offset]",
		Args:       cobra.RangeArgs(0, 2),
		PreRun:     loginPre,
		Run:        getContractsCmd,
	}

	getContractInfo = &cobra.Command{
		Use:   "getContractInfo [ContractName]",
		Short: "Get Contract Info",
		Long: `
Request:
	ContractName			(string) Contract name

Returns information about the specified contract.
	{
		"id": n,					(number) Contract ID in VM.
		"state": n,					(number) The ecosystem ID the contract belongs to.
		"tableid": "str",			(string) The ecosystem ID of the token used to pay contract fees.
		"walletid": "str",			(string) account address bound to the contract
		"tokenid": "str",			(string) The ecosystem ID of the token used to pay contract fees.
		"address": "str",			(string) The wallet address bound to the contract, example: XXXX-...-XXXX.
		"fields": [					(array) The array contains the structure information of each parameter in the contract data section:
			{
				"name": "str",		(string) The parameter name.
				"type": "str",		(string) The parameter type.
				"optional": bool	(boolean) parameter option, true means optional parameter, false means required parameter
			}
		],
		"name": "str"				(string) Contract name with ecosystem ID, example: @1MainCondition.
	}
`,
		SuggestFor: []string{"getContractInfo"},
		Example:    "./ibax-cli getContractInfo [ContractName]",
		Args:       cobra.ExactArgs(1),
		PreRun:     loginPre,
		Run:        getContractInfoCmd,
	}

	contractParamsFile string
	callContract       = &cobra.Command{
		Use:   "callContract [ContractName] [Params] [Expedite]",
		Short: "call IBAX contract",
		Long: `
Request:
	ContractName  		(string) call contract name
	Params 				(json object,optional) contract params
	Expedite			(string,optional) expedite unit: QIBAX

call IBAX contract AND return transaction status information

Returns a json object transaction status information.
Result:
	{
		"block_id": n,			(number) The block id generated by the transaction
		"hash": "str",			(string) The block hash generated by the transaction
		"penalty": n,			(number) If transaction execution fails, (0: no penalty 1: penalty)
		"err": ""				(string, optional) If the execution of the transaction fails, an error text message is returned.
	}
`,
		Example:    "./ibax-cli callContract [ContractName] [Params] [Expedite]",
		SuggestFor: []string{"callContract"},
		Args:       cobra.RangeArgs(1, 3),
		PreRun:     loginPre,
		Run:        callContractCmd,
	}
)

func getContractsCmd(cmd *cobra.Command, params []string) {
	args := parameter.New(params)
	limit, err := args.Set(0, false).NumberInt64()
	if err != nil {
		log.Infof("limit invalid:%s", err.Error())
		return
	}
	offset, err := args.Set(1, false).NumberInt64()
	if err != nil {
		log.Infof("offset invalid:%s", err.Error())
		return
	}

	result, err := models.Client.GetContracts(limit, offset)
	if err != nil {
		log.Infof("Get Contracts Failed: %s", err.Error())
		return
	}
	if result == nil {
		log.Info("Get Contracts Result Empty")
		return
	}
	str, err := json.MarshalIndent(*result, "", "    ")
	if err != nil {
		fmt.Printf("Result marshall Failed:%s\n", err.Error())
		return
	}
	fmt.Printf("\n%+v\n", string(str))
}

func getContractInfoCmd(cmd *cobra.Command, params []string) {
	args := parameter.New(params)
	contractName, err := args.Set(0, true).String()
	if err != nil {
		log.Infof("ContractName invalid:%s", err.Error())
		return
	}

	result, err := models.Client.GetContract(contractName)
	if err != nil {
		log.Infof("Get GetContract Failed: %s", err.Error())
		return
	}
	if result == nil {
		log.Info("Get GetContract Result Empty")
		return
	}
	str, err := json.MarshalIndent(*result, "", "    ")
	if err != nil {
		fmt.Printf("Result marshall Failed:%s\n", err.Error())
		return
	}
	fmt.Printf("\n%+v\n", string(str))
}

func isFileType(arr []string) bool { //{"Name": string, "MimeType": string, "Body": bytes}
	var hasName, hasMimeType, hasBody bool
	for _, key := range arr {
		if key == "Name" {
			hasName = true
		} else if key == "MimeType" {
			hasMimeType = true
		} else if key == "Body" {
			hasBody = true
		}
	}
	if hasName && hasMimeType && hasBody {
		return true
	}
	return false
}

func callContractCmd(cmd *cobra.Command, params []string) {
	if hasErrorContext(cmd) {
		return
	}

	args := parameter.New(params)
	contractName, err := args.Set(0, true).String()
	if err != nil {
		log.Infof("ContractName invalid:%s", err.Error())
		return
	}
	contractParamsStr, err := args.Set(1, false).String()
	if err != nil {
		log.Infof("Params invalid:%s", err.Error())
		return
	}

	expedite, err := args.Set(2, false).String()
	if err != nil {
		log.Infof("Expedite invalid:%s", err.Error())
		return
	}

	if contractParamsFile != "" {
		data, err := os.ReadFile(contractParamsFile)
		if err != nil {
			log.Infof("ReadFile Failed:%s", err.Error())
			return
		}
		contractParamsStr = string(data)
	}
	//models.Client.PrepareContractTx()
	var contractParams request.MapParams
	if contractParamsStr != "" {
		err := json.Unmarshal([]byte(contractParamsStr), &contractParams)
		if err != nil {
			log.Infof("Params JSON Parsing Failed: %s", err.Error())
			return
		}
		const fileSuffix = "-file"
		for k, v := range contractParams {
			switch v.(type) {
			case map[string]interface{}:
				m := v.(map[string]interface{})
				var keys []string
				for mk, mv := range m {
					if strings.HasSuffix(mk, fileSuffix) {
						paramsName := mk[:len(fileSuffix)-1]
						switch mv.(type) {
						case string:
							data, err := os.ReadFile(mv.(string))
							if err != nil {
								log.Infof("parse params file failed: %s", err.Error())
								return
							}
							delete(m, mk)
							m[paramsName] = string(data)
							keys = append(keys, paramsName)
						default:
							log.Infof("params %s file type invalid", mk)
						}
					} else {
						keys = append(keys, mk)
					}
				}
				contractParams[k] = m
				if isFileType(keys) {
					for mk, mv := range m {
						if mk == "Body" {
							switch mv.(type) {
							case string:
								str := mv.(string)
								m[mk] = []byte(str)
							}
						}
					}
					contractParams[k] = m
				}
			}
			if strings.HasSuffix(k, fileSuffix) {
				paramsName := k[:len(fileSuffix)-1]
				data, err := os.ReadFile(contractParams.Get(k))
				if err != nil {
					log.Infof("parse params file failed: %s", err.Error())
					return
				}
				delete(contractParams, k)
				contractParams[paramsName] = string(data)
			}
		}
	}

	result, err := models.Client.AutoCallContract(contractName, &contractParams, expedite)
	if err != nil {
		log.Infof("Call Contract Failed: %s", err.Error())
		return
	}
	if result == nil {
		log.Info("Call Contract Result Empty")
		return
	}
	str, err := json.MarshalIndent(*result, "", "    ")
	if err != nil {
		fmt.Printf("Result marshall Failed:%s\n", err.Error())
		return
	}
	fmt.Printf("\n%+v\n", string(str))
}
